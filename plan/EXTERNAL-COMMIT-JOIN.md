# Direct Key Package Join

**Status**: Implemented

## Problem

### Previous Behaviour

The original external join flow used MLS external commits: the joiner
fetched the group's ratchet tree from an acceptor, constructed an
`ExternalCommit`, and sent it back. This required `FetchTree` and
`ExternalCommit` handshake variants, acceptor-side tree export, and a
`GroupInfo` payload that encoded the invited-by member for compaction
leader election. The flow did not support Paxos consensus and was
difficult to extend.

### Replacement

A simpler flow where the joiner sends a key package directly to an
existing group member over iroh, and that member adds them through the
normal Paxos-backed `add_member` path. Invite codes include an HMAC
tag derived from the MLS epoch's export secret to prevent abuse.

## Current Design

### Invite Code

The invite code is 96 bytes, base58-encoded:

```
[ endpoint_id (32) | group_id (32) | hmac_tag (32) ]
```

`endpoint_id` is the iroh `PublicKey` of the inviter. `group_id` is
the MLS group identifier. `hmac_tag` is
`HMAC-SHA256(export_secret, endpoint_id || group_id)` where
`export_secret = group.export_secret(b"filament/invite", b"", 32)`.

The export secret changes every epoch, so invite codes automatically
expire on epoch advance. The invite is re-fetched by the UI whenever
`groupState` changes.

Generated by `Weaver::generate_invite()` (routed through
`DocRequest::GenerateExternalInvite`) and exposed via the
`generate_external_invite` tauri command. The ShareModal fetches it
on mount and on every epoch change.

### Join Flow

1. **Inviter** opens the Share modal. The invite code is displayed
   automatically.
2. **Joiner** pastes the invite code and clicks Join.
3. **Joiner's coordinator** decodes the 96-byte invite, extracts
   `target`, `group_id`, and `hmac_tag`, then calls
   `WeaverClient::send_key_package(target, group_id, hmac_tag)`.
   This generates a fresh MLS `KeyPackage`, connects to the target's
   iroh endpoint, and sends a
   `Handshake::SendKeyPackage { group_id, key_package, hmac_tag }`
   message. The command returns immediately after the send completes.
4. **Inviter's `incoming_loop`** receives the key package, looks up
   the `group_id` in the `GroupRegistry`, and sends a
   `GroupRequest::IncomingKeyPackage` directly to the group actor.
5. **GroupActor** verifies the HMAC tag against its own export secret.
   If valid, it calls `handle_add_member` through the normal Paxos
   commit flow, which sends a welcome message. If invalid, the
   key package is rejected with a warning log.
6. **Joiner's coordinator** receives the welcome via `welcome_rx` (the
   joiner had called `recvWelcome` after the send). The welcome is
   processed via `join_with_welcome`, creating the document actor.

### Group Registry

`WeaverClient` holds a `GroupRegistry`
(`Arc<Mutex<HashMap<GroupId, mpsc::Sender<GroupRequest>>>>`). When a
`Weaver` is created or joined, its `request_tx` is registered in the
registry. The `incoming_loop` uses the registry to route incoming key
packages directly to the correct group actor, bypassing the editor
layer entirely.

### Key Types and Modules

| Component | Location |
|-----------|----------|
| `Handshake::SendKeyPackage` | `filament-core/src/protocol.rs` |
| `compute_invite_hmac` | `filament-weave/src/group/mod.rs` |
| `GroupRequest::IncomingKeyPackage` | `filament-weave/src/group/mod.rs` |
| `GroupRequest::GenerateInvite` | `filament-weave/src/group/mod.rs` |
| `GroupRequest::VerifyInviteTag` | `filament-weave/src/group/mod.rs` |
| `Weaver::generate_invite` | `filament-weave/src/group/mod.rs` |
| `Weaver::verify_invite_tag` | `filament-weave/src/group/mod.rs` |
| `GroupRegistry` | `filament-weave/src/group/mod.rs` |
| `WeaverClient::send_key_package` | `filament-weave/src/client.rs` |
| `WeaverClient::incoming_loop` | `filament-weave/src/client.rs` |
| `wait_for_incoming` â†’ `IncomingHandshake::KeyPackage` | `filament-weave/src/group/mod.rs` |
| `CoordinatorActor::send_key_package_from_invite` | `filament-editor/src/actor.rs` |
| `DocRequest::GenerateExternalInvite` | `filament-editor/src/types.rs` |

### What Was Removed

From the original external commit flow:
- `Handshake::FetchTree`, `Handshake::ExternalCommit`, `HandshakeResponse::Data`
- `GroupInfoExt::invited_by` field and `with_invited_by()` method
- `Weaver::join_external()`, `Weaver::generate_external_group_info()`
- `WeaverClient::join_external()`, `parse_group_info_metadata()`, `GroupInfoMetadata`
- `GroupRequest::GenerateExternalGroupInfo`
- `GroupAcceptor::export_tree()`, `confirmed_transcript_hash()`, `snapshot_bytes()`
- `AcceptorRegistry::export_tree()`, `apply_external_commit()`
- `handle_fetch_tree()`, `handle_external_commit()` in spool server

From the editor-routed key package handling (moved into weave):
- `WeaverClient::recv_key_package`, `take_key_package_rx`
- `CoordinatorActor::handle_key_package_received`
- `CoordinatorActor::generate_external_invite`
- `DocRequest::VerifyInviteTag`
