# Direct Key Package Join

**Status**: Implemented

## Problem

### Previous Behaviour

The original external join flow used MLS external commits: the joiner
fetched the group's ratchet tree from an acceptor, constructed an
`ExternalCommit`, and sent it back. This required `FetchTree` and
`ExternalCommit` handshake variants, acceptor-side tree export, and a
`GroupInfo` payload that encoded the invited-by member for compaction
leader election. The flow did not support Paxos consensus and was
difficult to extend.

### Replacement

A simpler flow where the joiner sends a key package directly to an
existing group member over iroh, and that member adds them through the
normal Paxos-backed `add_member` path.

## Current Design

### Invite Code

The invite code is 64 bytes, base58-encoded:

```
[ endpoint_id (32 bytes) | group_id (32 bytes) ]
```

`endpoint_id` is the iroh `PublicKey` of the inviter. `group_id` is
the MLS group identifier. The code is deterministic for a given
group on a given device.

Generated by `CoordinatorActor::generate_external_invite()` and
exposed via the `generate_external_invite` tauri command. The
ShareModal fetches it on mount and always displays it.

### Join Flow

1. **Inviter** opens the Share modal. The invite code is displayed
   automatically.
2. **Joiner** pastes the invite code and clicks Join.
3. **Joiner's coordinator** decodes the invite, extracts `target` and
   `group_id`, and calls `WeaverClient::send_key_package(target, group_id)`.
   This generates a fresh MLS `KeyPackage`, connects to the target's iroh
   endpoint, and sends a `Handshake::SendKeyPackage { group_id, key_package }`
   message. The command returns immediately after the send completes.
4. **Inviter's coordinator** receives the key package via `key_package_rx`
   in its select loop and routes it as a `DocRequest::AddMember` to the
   document actor for the matching `group_id`. The member is added through
   the normal Paxos commit flow, which sends a welcome message.
5. **Joiner's coordinator** receives the welcome via `welcome_rx` (the
   joiner had called `recvWelcome` after the send). The welcome is
   processed via `join_with_welcome`, creating the document actor.

### Key Types and Modules

| Component | Location |
|-----------|----------|
| `Handshake::SendKeyPackage` | `filament-core/src/protocol.rs` |
| `WeaverClient::send_key_package` | `filament-weave/src/client.rs` |
| `WeaverClient::take_key_package_rx` | `filament-weave/src/client.rs` |
| `wait_for_incoming` â†’ `IncomingHandshake::KeyPackage` | `filament-weave/src/group/mod.rs` |
| `CoordinatorActor::handle_key_package_received` | `filament-editor/src/actor.rs` |
| `CoordinatorActor::send_key_package_from_invite` | `filament-editor/src/actor.rs` |
| `CoordinatorActor::generate_external_invite` | `filament-editor/src/actor.rs` |

### What Was Removed

- `Handshake::FetchTree`, `Handshake::ExternalCommit`, `HandshakeResponse::Data`
- `GroupInfoExt::invited_by` field and `with_invited_by()` method
- `Weaver::join_external()`, `Weaver::generate_external_group_info()`
- `WeaverClient::join_external()`, `parse_group_info_metadata()`, `GroupInfoMetadata`
- `GroupRequest::GenerateExternalGroupInfo`
- `GroupAcceptor::export_tree()`, `confirmed_transcript_hash()`, `snapshot_bytes()`
- `AcceptorRegistry::export_tree()`, `apply_external_commit()`
- `handle_fetch_tree()`, `handle_external_commit()` in spool server
- `DocRequest::GenerateExternalInvite` (moved to `CoordinatorRequest`)
